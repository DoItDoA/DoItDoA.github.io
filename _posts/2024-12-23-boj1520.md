---
title:  "백준 1520번 문제와 메모이제이션"
layout: single
categories: algorithm
tag: [Java, algorithm]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
---
# 참고
이 글은 어느정도 DFS에 대해서 알고 메모이제이션에 대해서 간단히 알고 싶은 경우에 보는 것을 추천

# 메모이제이션이란?
이미 계산한 결과를 저장해두고, 필요할 때 다시 사용하는 방법  
즉, 불필요한 중복을 방지한다.  
좀 더 이해를 위해 예시로 들어보자

# 백준 1520번 문제
[문제 링크](https://www.acmicpc.net/problem/1520)  
문제를 간단히 설명하자면  
<table border="1" style="border: 1px solid black; text-align: center;">
  <tr>
    <td>4</td>
    <td>3</td>
    <td>2</td>
  </tr>
  <tr>
    <td>3</td>
    <td>2</td>
    <td>1</td>
  </tr>
  <tr>
    <td>2</td>
    <td>1</td>
    <td>0</td>
  </tr>
</table>

(0,0)에서 시작하여 현재 위치보다 숫자가 작아야하고  
상하좌우 한칸씩 이동하여 (2,2)까지 이동하는 것이다.  
정답은 6  
<br/>
이때 당시 나는 DFS를 이용하여 단순히 문제를 풀었으며 처리 시간초과로 인해 문제를 틀렸다.  
단순히 DFS를 문제를 풀면 경로 방향이 아래처럼 된다.  
![경로](/assets/images/dp.PNG)  
그림처럼 총 6가지 방향이 나온다.  
그렇지만 문제점은 일부 경로를 중복으로 다녀서 그만큼 처리시간도 길다.
이와 같이 중복을 해결하기 위해 사용되는 방법이 메모이제이션이다.  

# 메모이제이션 사용 예시
나는 메모이제이션이 조금 복잡하다고 생각하여 단순히 그림으로 표현하려고 한다.
DFS를 사용하면 갔던 경로를 되돌아가면서 하나씩 다른 방향도 체크한다.  
(0, 0) -> (0, 1) -> (0, 2) -> (1, 2) -> (2, 2) -> <u>(1, 2) -> (0, 2) -> (0, 1)</u> -> (1, 1) -> ...  
위 좌표의 밑줄 그어진 부분이 왔던 경로를 되돌아가는 부분이다.  

<br/>
![dp](/assets/images/dp1.PNG)  
처음



# 코드 예시
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    private static int[][] map, dp;
    private static int n, m;
    private static int[] dy = {0, 1, 0, -1};
    private static int[] dx = {1, 0, -1, 0};

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        n = Integer.parseInt(input[0]);
        m = Integer.parseInt(input[1]);

        map = new int[n][m];
        dp = new int[n][m]; // 메모이제이션 배열

        for (int y = 0; y < n; y++) {
            String[] val = br.readLine().split(" ");
            for (int x = 0; x < m; x++) {
                map[y][x] = Integer.parseInt(val[x]);
                dp[y][x] = -1; // 초기화
            }
        }
        int dfs = dfs(0, 0);
        // 시작점에서 DFS 수행
        System.out.println(dfs);
    }

    static int dfs(int y, int x) {
        // 도착지에 도달하면 1 반환
        if (y == n - 1 && x == m - 1) {
            return 1;
        }

        // 이미 계산된 값이 있다면 반환
        if (dp[y][x] != -1) {
            return dp[y][x];
        }

        // 현재 위치에서 가능한 경로 수 계산
        dp[y][x] = 0;
        for (int k = 0; k < 4; k++) {
            int ny = y + dy[k];
            int nx = x + dx[k];

            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                if (map[ny][nx] < map[y][x]) {
                    dp[y][x] += dfs(ny, nx);
                }
            }
        }

        return dp[y][x];
    }
}
```
