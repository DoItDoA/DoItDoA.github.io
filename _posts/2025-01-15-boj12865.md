---
title:  "백준 15865번 문제와 냅색 알고리즘"
layout: single
categories: Algorithm
tag: [Java, Algorithm]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
---
# 냅색 이란?
Knapsack으로 쓰고 직역하자면 배낭이다.  
이 알고리즘은 배낭에 무게를 최소화하면서 가치를 최대한 높이는게 핵심이다.   

# 백준 1520번 문제
[문제 링크](https://www.acmicpc.net/problem/12865)  
문제에서 
총 개수(N)는 4   
감당 가능한 무게(K)는 7   
|W(무게)|V(가치)|
|--|--|
|6|13|
|4|8|
|3|6|
|5|12|
<br/>
필자는 처음에 백트래킹으로 풀려고 했으나 N=100이면 시간복잡도가 O(2^100)이라 시간이 매우 오래걸린다.   
dp를 활용하여 식을 만들었고  
이해하기 어려웠지만 코드 흐름대로 설명을 쉽게 설명하려고 한다.  

# 냅색 알고리즘 사용 예시
감당 가능한 무게(K)가 7이면 거기에 맞는 dp크기 7의 공간을 만든다.
```java
int[] dp = new int[K + 1]; // 인덱스 1~7까지 활용하기 위해 +1 사용
```
여기서  
dp[7]이면 무게 7까지 감당가능  
dp[6]이면 무게 6까지 감당가능  
dp[5]이면 무게 5까지 감당가능  
...  
즉 1~7까지 각각 무게 감당 가능한 배낭이 7개 있다고 보면 된다. 
</br>
처음에는 배낭에 아무것도 안들어 있으니
|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|0|0|0|0|

이렇게 구성되어 있다.

여기서 첫번째로 무게가 6이고 가치가 13인 물건을 넣을 때  
1. 배낭이 큰 순서대로 각각 담아본다.(7부터 1까지)  
2. 배낭이 7일 때 무게가 6인 물건을 담을 수 있다.  
3. 담고나면 공간 1이 남기 때문에 배낭 1에서 뭔가를 꺼내 담아보려지만 아무것도 없다.

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|0|0|0|13+0|

여기서 +0은 배낭 1에 담긴 가치(0)를 꺼내 담은 것이다.

4. 배낭이 6일 때 무게가 6인 물건을 담을 수 있다.
5. 완전히 담았기 때문에 더 담을 수 없다.

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|0|0|13|13+0|




![dp](/assets/images/dp/dp1.PNG)  
처음에는 위 그림처럼 지나가면서 처음 지나가는 길은 *0*으로 배치한다.  
<br/>
![dp](/assets/images/dp/dp2.PNG)  
도착 지점에 왔으면 DFS의 흐름에 따라 이제 다시 왔던길을 되돌아간다.  
이때 도착 지점에 도착한 경로는 되돌아갈때 도착정보 *1*을 가져오며 배치한다. 
<br/>  
![dp](/assets/images/dp/dp3.PNG)  
(0, 1)에서 하단으로 이동하며 위 그림처럼 이동한다.  
이때 또 처음 가는 경로는 *0*을 배치한다.  
<br/>
![dp](/assets/images/dp/dp4.PNG)  
(1, 2)는 한번 갔던 경로이고 그 경로를 통해 이미 도착지점에 갔으니 또 갈 필요없다.  
그래서 왔던 경로를 되돌아가며 되돌아갈 시 (1, 2)에 배치된 도착정보 *1*을 가져온다.  
(1, 1)에서 오른쪽으로부터 가져온 도착정보 *1*과 처음가는 경로 *0*을 더한다. (1 + 0)  
그럼 두번째 경로도 도착 완료이다.  
<br/>
![dp](/assets/images/dp/dp5.PNG)  
이제 (1, 1)에서 다시 아래쪽으로 내려가며 처음 가는 경로는 *0*으로 표기하며 간다.  
<br/>
![dp](/assets/images/dp/dp6.PNG)  
도착지점에 도착 후 다시 되돌아가며 도착정보 *1*을 가져온다.  
다시 (1, 1)에서 아래로부터 가져온 도착정보 *1*과 이미 가지고 있는 도착정보 *1*을 더한다. (1 + 1)  
그럼 세번째 경로도 도착 완료이다.  
<br/>
![dp](/assets/images/dp/dp7.PNG)  
DFS의 알고리즘에 따라 왔던 경로를 되돌아 가면서 도착정보를 더해가면서 되돌아간다.  
(0, 1)에서 1 + 2  
(0, 0)에서 0 + 3  
<br/>
![dp](/assets/images/dp/dp8.PNG)  
위 이미지처럼 이동하며 처음가는 경로는 *0*을 배치한다.  
<br/>
![dp](/assets/images/dp/dp9.PNG)  
(1, 1)은 이미 갔던 경로이므로 다시 되돌아간다.  
되돌아갈 때 도착정보 *2*를 가져가며 되돌아간다.  
(1, 0)에서 처음 가는 경로 *0*과 도착정보 *2*를 더한다. (0 + 2)  
<br/>
![dp](/assets/images/dp/dp10.PNG)  
위 이미지처럼 아래로 이동하며 처음가는 경로는 *0*을 배치한다.  
<br/>
![dp](/assets/images/dp/dp11.PNG)  
(2, 1)은 이미 갔던 경로이므로 다시 되돌아간다.  
되돌아갈 때 도착정보 *1*을 가져가며 되돌아간다.  
(1, 0)에서 이미 가져온 도착정보 *2*와 방금 가져온 도착정보 *1*을 더한다. (2 + 1)  
<br/>
![dp](/assets/images/dp/dp12.PNG)  
처음 (0, 0)으로 돌아가면서 모든 도착정보를 더한다. (3 + 3)  
더한 모든 도착 정보가 모든 경로의 수이다.  
<br/>
정리하자면  
이미 갔던 경로는 가지않고 도착정보만을 가져와서 모두 더하여 출력하기 때문에 중복의 발생이 없다.  
즉, 처리 시간을 많이 줄일수가 있다.  
<br/>
# 코드 예시
```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    private static int[][] map, dp;
    private static int n, m;
    private static int[] dy = {0, 1, 0, -1};
    private static int[] dx = {1, 0, -1, 0};

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");
        n = Integer.parseInt(input[0]);
        m = Integer.parseInt(input[1]);

        map = new int[n][m];
        dp = new int[n][m]; // 메모이제이션 배열

        for (int y = 0; y < n; y++) {
            String[] val = br.readLine().split(" ");
            for (int x = 0; x < m; x++) {
                map[y][x] = Integer.parseInt(val[x]);
                dp[y][x] = -1; // 초기화
            }
        }
        int dfs = dfs(0, 0);
        // 시작점에서 DFS 수행
        System.out.println(dfs);
    }

    static int dfs(int y, int x) {
        // 도착지에 도달하면 1 반환
        if (y == n - 1 && x == m - 1) {
            return 1;
        }

        // 이미 계산된 값이 있다면 반환
        if (dp[y][x] != -1) {
            return dp[y][x];
        }

        // 현재 위치에서 가능한 경로 수 계산
        dp[y][x] = 0;
        for (int k = 0; k < 4; k++) {
            int ny = y + dy[k];
            int nx = x + dx[k];

            if (nx >= 0 && nx < m && ny >= 0 && ny < n) {
                if (map[ny][nx] < map[y][x]) {
                    dp[y][x] += dfs(ny, nx);
                }
            }
        }

        return dp[y][x];
    }
}
```
