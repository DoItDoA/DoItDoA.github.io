---
title:  "백준 15865번 문제와 냅색 알고리즘"
layout: single
categories: Algorithm
tag: [Java, Algorithm]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
---
# 냅색 이란?
Knapsack으로 쓰고 직역하자면 배낭이다.  
이 알고리즘은 배낭에 무게를 최소화하면서 가치를 최대한 높이는게 핵심이다.   

# 백준 1520번 문제
[문제 링크](https://www.acmicpc.net/problem/12865)  
문제에서 
총 개수(N)는 4   
감당 가능한 무게(K)는 7   
|W(무게)|V(가치)|
|--|--|
|6|13|
|4|8|
|3|6|
|5|12|
<br/>
필자는 처음에 백트래킹으로 풀려고 했으나  
N=100이면 시간복잡도가 O(2^100)이라 시간이 매우 오래걸린다.  
dp를 활용하여 식을 만들었고  
이해하기 어려웠지만 코드 흐름대로 설명을 쉽게 설명하려고 한다.  

# 냅색 알고리즘 사용 예시
감당 가능한 무게(K)가 7이면 거기에 맞는 dp크기 7의 공간을 만든다.
```java
int[] dp = new int[K + 1]; // 인덱스 1~7까지 활용하기 위해 +1 사용
```
여기서  
dp[7]이면 무게 7까지 감당가능  
dp[6]이면 무게 6까지 감당가능  
dp[5]이면 무게 5까지 감당가능  
...  
즉 1~7까지 각각 무게 감당 가능한 배낭이 7개 있다고 보면 된다. 
</br>
처음에는 배낭에 아무것도 안들어 있으니
|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|0|0|0|0|

이렇게 구성되어 있다.

여기서 첫번째로 무게가 6이고 가치가 13인 물건을 넣을 때  
1. 배낭이 큰 순서대로 각각 담아본다.(7부터 1까지)  
2. 배낭이 7일 때 무게가 6인 물건을 담을 수 있다.  
3. 담고나면 공간 1이 남기 때문에 배낭 1에서 뭔가를 꺼내 담아보려지만 아무것도 없다.

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0(아무것도 없음)|0|0|0|0|0|13+0|

여기서 +0은 배낭 1에 담긴 가치(0)를 꺼내 담은 것이다.

4. 배낭이 6일 때 무게가 6인 물건을 담을 수 있다.
5. 완전히 담았기 때문에 더 담을 수 없다.

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|0|0|13|13+0|

6. 배낭이 5이하 부터는 무게가 6인 물건을 담을 수 없다.
   
여기까지 코드를 살펴보자면  
```java
// W[]는 상품의 무게
// V[]는 상품의 가치

int[] dp = new int[K + 1];

for (int i = 0; i < N; i++) { // i는 각각의 상품 선택
    int weight = W[i]; // i가 0이면 무게가 6인 상품  

    // K는 감당 가능한 배낭무게 선택
    for (int j = K; j >= weight; j--) { // 제일 큰 배낭 7부터 감당 가능한 배낭6까지 선택
        int val = V[i]; // 무게가 6인 상품의 가치(13)

        int plus = dp[j - W[i]]; // j가 제일 큰 배낭(7)이면 무게가 6일때 1이 남음
                                 // 배낭1(dp[1])에서 꺼내올 가치 찾음

        dp[j] = val + plus; // 배낭1에서 가져온 가치와 무게가 6인 가치(13)를 더해 배낭7에 담음
    }
}
```
중간까지의 코드 구성이다.  

두번째로 무게가 4이고 가치가 8인 물건을 넣어볼 때  
1. 배낭이 큰 순서대로 각각 담아본다.(7부터 1까지)  
2. 배낭이 7일 때 무게가 4인 물건을 담을 수 있다.  
3. 담고나면 공간 3이 남기 때문에 배낭 3에서 뭔가를 꺼내 담아보려지만 아무것도 없다.(8+0)
4. 배낭 7에는 가치가 13인 물건이 이미 담겨있다.
5. 13과 8+0 중 큰 가치는 13이다. 즉, 배낭 7에 13을 그대로 둔다.
6. 배낭 6도 13이 담겨 있고 8+0(여기서 +0은 배낭 2에서 가져온 가치)과 비교하여 13을 선택

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|0|0|13(13과 8을 비교)|13(13과 8을 비교)|

7. 배낭 5는 아무것도 안담겨 있고 8+0을 담음(여기서 +0은 배낭 1에서 가져온 가치)
8. 배낭 4는 완전히 담을 수 있다.

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|8|8+0|13(13과 8을 비교)|13(13과 8을 비교)|

여기까지 코드를 살펴보자면  
```java
// W[]는 상품의 무게
// V[]는 상품의 가치

int[] dp = new int[K + 1];

for (int i = 0; i < N; i++) { 
    int weight = W[i]; // i가 1이면 무게가 4인 상품  

    for (int j = K; j >= weight; j--) { 
        int val = V[i]; // 무게가 4인 상품의 가치(8)

        int plus = dp[j - W[i]]; // j가 제일 큰 배낭(7)이면 무게가 4일때 3이 남음
                                 // 배낭3(dp[3])에서 꺼내올 가치 찾음

        int prevVal = dp[j]; // 기존의 j가 제일 큰 배낭(7)에 담긴 가치 13 

        dp[j] = Math.max(val + plus, prevVal); // [배낭7에 담긴 가치(13)]과 [무게가 4인 가치(8) + 배낭3에서 가져온 가치(0)]의 비교
    }
}
```
