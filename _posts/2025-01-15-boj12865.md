---
title:  "백준 15865번 문제와 냅색 알고리즘"
layout: single
categories: Algorithm
tag: [Java, Algorithm]
toc: true
toc_sticky: true
author_profile: false
sidebar:
    nav: "docs"
---
# 냅색 이란?
Knapsack으로 쓰고 직역하자면 배낭이다.  
이 알고리즘은 배낭에 무게를 최소화하면서 가치를 최대한 높이는게 핵심이다.   

# 백준 15865번 문제
[문제 링크](https://www.acmicpc.net/problem/12865)  
문제에서  
총 개수(N)는 4   
감당 가능한 무게(K)는 7   

<table style="text-align: center;">
  <tr>
    <td style="border:1px solid black">W(무게)</td>
    <td style="border:1px solid black">V(가치)</td>
  </tr>
  <tr>
    <td style="border:1px solid black">6</td>
    <td style="border:1px solid black">13</td>
  </tr>
  <tr>
    <td style="border:1px solid black">4</td>
    <td style="border:1px solid black">8</td>
  </tr>
  <tr>
    <td style="border:1px solid black">3</td>
    <td style="border:1px solid black">6</td>
  </tr>
  <tr>
    <td style="border:1px solid black">5</td>
    <td style="border:1px solid black">12</td>
  </tr>
</table>
<br/>
필자는 처음에 백트래킹으로 풀려고 했으나  
N=100이면 시간복잡도가 O(2^100)이라 시간이 매우 오래걸린다.  
dp를 활용하여 식을 만들었고  
이해하기 어려웠지만 코드 흐름대로 설명을 쉽게 설명하려고 한다.  
<br>
# 냅색 알고리즘 사용 예시
감당 가능한 무게(K)가 7이면 거기에 맞는 dp크기 7의 공간을 만든다.
```java
int[] dp = new int[K + 1]; // 인덱스 1~7까지 활용하기 위해 +1 사용
```
여기서  
dp[7]이면 무게 7까지 감당가능  
dp[6]이면 무게 6까지 감당가능  
dp[5]이면 무게 5까지 감당가능  
...  
즉 1~7까지 각각 무게 감당 가능한 배낭이 7개 있다고 보면 된다. 
</br>
처음에는 배낭에 아무것도 안들어 있으니
|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|0|0|0|0|
<table style="text-align: center;">
  <tr>
    <td style="border:1px solid black; background-color:ffffe0">배낭(무게)</td>
    <td style="border:1px solid black">1</td>
    <td style="border:1px solid black">2</td>
    <td style="border:1px solid black">3</td>
    <td style="border:1px solid black">4</td>
    <td style="border:1px solid black">5</td>
    <td style="border:1px solid black">6</td>
    <td style="border:1px solid black">7</td>
  </tr>
  <tr>
    <td style="border:1px solid black">가치(V)</td>
    <td style="border:1px solid black">0</td>
    <td style="border:1px solid black">0</td>
    <td style="border:1px solid black">0</td>
    <td style="border:1px solid black">0</td>
    <td style="border:1px solid black">0</td>
    <td style="border:1px solid black">0</td>
    <td style="border:1px solid black">0</td>
  </tr>
</table>
이렇게 구성되어 있다.

여기서 첫번째로 무게가 6이고 가치가 13인 물건을 넣을 때  
1. 배낭이 큰 순서대로 각각 담아본다.(7부터 1까지)  
2. 배낭이 7일 때 무게가 6인 물건을 담을 수 있다.  
3. 담고나면 공간 1이 남기 때문에 배낭 1에서 뭔가를 꺼내 담아보려지만 아무것도 없다.

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0(아무것도 없음)|0|0|0|0|0|13+0|

여기서 +0은 배낭 1에 담긴 가치(0)를 꺼내 담은 것이다.

4. 배낭이 6일 때 무게가 6인 물건을 담을 수 있다.
5. 완전히 담았기 때문에 더 담을 수 없다.

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|0|0|13|13+0|

6. 배낭이 5이하 부터는 무게가 6인 물건을 담을 수 없다.
   
여기까지 코드를 살펴보자면  
```java
// W[]는 상품의 무게
// V[]는 상품의 가치

int[] dp = new int[K + 1];

for (int i = 0; i < N; i++) { // i는 각각의 상품 선택
    int weight = W[i]; // i가 0이면 무게가 6인 상품  

    // K는 감당 가능한 배낭무게 선택
    for (int j = K; j >= weight; j--) { // 제일 큰 배낭 7부터 감당 가능한 배낭6까지 선택
        int val = V[i]; // 무게가 6인 상품의 가치(13)

        int plus = dp[j - W[i]]; // j가 제일 큰 배낭(7)이면 무게가 6일때 1이 남음
                                 // 배낭1(dp[1])에서 꺼내올 가치 찾음

        dp[j] = val + plus; // 배낭1에서 가져온 가치와 무게가 6인 가치(13)를 더해 배낭7에 담음
    }
}
```
중간까지의 코드 구성이다.  

두번째로 무게가 4이고 가치가 8인 물건을 넣어볼 때  
1. 배낭이 큰 순서대로 각각 담아본다.(7부터 1까지)  
2. 배낭이 7일 때 무게가 4인 물건을 담을 수 있다.  
3. 담고나면 공간 3이 남기 때문에 배낭 3에서 뭔가를 꺼내 담아보려지만 아무것도 없다.(8+0)
4. 배낭 7에는 가치가 13인 물건이 이미 담겨있다.
5. 13과 8+0 중 큰 가치는 13이다. 즉, 배낭 7에 13을 그대로 둔다.
6. 배낭 6도 13이 담겨 있고 8+0(여기서 +0은 배낭 2에서 가져온 가치)과 비교하여 13을 선택

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|0|0|13(13과 8을 비교)|13(13과 8을 비교)|

7. 배낭 5는 아무것도 안담겨 있고 8+0을 담음(여기서 +0은 배낭 1에서 가져온 가치)
8. 배낭 4는 완전히 담을 수 있다.
9. 배낭 3이하부터는 담을 수 없다. 

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|8|8+0|13(13과 8을 비교)|13(13과 8을 비교)|

여기까지 코드를 살펴보자면  
```java
// W[]는 상품의 무게
// V[]는 상품의 가치

int[] dp = new int[K + 1];

for (int i = 0; i < N; i++) { 
    int weight = W[i]; // i가 1이면 무게가 4인 상품  

    for (int j = K; j >= weight; j--) { 
        int val = V[i]; // 무게가 4인 상품의 가치(8)

        int plus = dp[j - W[i]]; // j가 제일 큰 배낭(7)이면 무게가 4일때 3이 남음
                                 // 배낭3(dp[3])에서 꺼내올 가치 찾음

        int prevVal = dp[j]; // 기존의 j가 제일 큰 배낭(7)에 담긴 가치 13 

        dp[j] = Math.max(val + plus, prevVal); // [배낭7에 담긴 가치(13)]과 [무게가 4인 가치(8) + 배낭3에서 가져온 가치(0)]의 비교
    }
}
```
현재 코드는 이게 정답이지만 이해를 위해 좀 더 설명하겠다.  

세번째로 무게가 3이고 가치가 6인 물건을 넣어볼 때  
1. 배낭이 큰 순서대로 각각 담아본다.(7부터 1까지)  
2. 배낭이 7일 때 무게가 3인 물건을 담을 수 있다.  
3. 담고나면 공간 4이 남기 때문에 배낭 4에 담긴 8의 가치를 꺼내 6과 함께 배낭 7에 담는다. (6+8)

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|0|8(꺼냄)|8|13|13|

4. 배낭 7에는 가치가 13인 물건이 이미 담겨있다.
5. 13과 14(6+8) 중 큰 가치는 14이다. 즉, 배낭 7에서 14로 교체한다.
6. 배낭 6도 13이 담겨 있고 6+0(여기서 +0은 배낭 3에서 가져온 가치)과 비교하여 13을 선택
7. 배낭 5도 8이 담겨 있고 6+0(여기서 +0은 배낭 2에서 가져온 가치)과 비교하여 8을 선택
8. 배낭 4도 4이 담겨 있고 6+0(여기서 +0은 배낭 1에서 가져온 가치)과 비교하여 8을 선택
9. 배낭 3은 완전히 담을 수 있다.
10. 배낭 2이하부터는 담을 수 없다. 

세번째가 끝나면 배낭 구성은 아래와 같다.  
|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|6|8|8|13|14(6+8)|

```java
// W[]는 상품의 무게
// V[]는 상품의 가치

int[] dp = new int[K + 1];

for (int i = 0; i < N; i++) { 
    int weight = W[i]; // i가 2이면 무게가 3인 상품  

    for (int j = K; j >= weight; j--) { 
        int val = V[i]; // 무게가 3인 상품의 가치(6)

        int plus = dp[j - W[i]]; // j가 제일 큰 배낭(7)이면 무게가 3일때 4가 남음
                                 // 배낭4(dp[4])에서 꺼내올 가치 찾음(8)

        int prevVal = dp[j]; // 기존의 j가 제일 큰 배낭(7)에 담긴 가치 13 

        dp[j] = Math.max(val + plus, prevVal); // [배낭7에 담긴 가치(13)]과 [무게가 3인 가치(6) + 배낭3에서 가져온 가치(8)]의 비교
    }
}
```

마지막으로 무게가 5이고 가치가 12인 물건을 넣어볼 때  
1. 배낭이 큰 순서대로 각각 담아본다.(7부터 1까지)  
2. 배낭이 7일 때 무게가 5인 물건을 담을 수 있다.  
3. 담고나면 무게 2가 남기 때문에 배낭 2에서 뭔가를 꺼내 담아보려지만 아무것도 없다.

|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0(꺼냄)|6|8|8|13|14|

4. 배낭 7에는 가치가 14인 물건이 이미 담겨있다.
5. 14와 12+0 중 큰 가치는 14이다. 즉, 14로 그대로 둔다.
6. 배낭 6도 13이 담겨 있고 12+0(여기서 +0은 배낭 1에서 가져온 가치)과 비교하여 13을 선택
7. 배낭 5는 완전히 담을 수 있다.
8. 배낭 5에는 8이 담겨있지만 12와 비교하여 12로 교체
9. 배낭 4이하부터는 담을 수 없다. 

마지막이 끝나면 배낭 구성은 아래와 같다.  
|배낭(무게)|1|2|3|4|5|6|7|
|--|--|--|--|--|--|--|--|
|가치(V)|0|0|6|8|12|13|14|

여기서 배낭 7의 가치를 꺼내면 정답이다.

최종코드는 이렇다.
```java
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");

        int N = Integer.parseInt(input[0]);
        int K = Integer.parseInt(input[1]);
        int[] W = new int[N];
        int[] V = new int[N];

        for (int i = 0; i < N; i++) {
            String[] val = br.readLine().split(" ");
            W[i] = Integer.parseInt(val[0]);
            V[i] = Integer.parseInt(val[1]);
        }

        int[] dp = new int[K + 1];

        for (int i = 0; i < N; i++) {
            for (int j = K; j >= W[i]; j--) { 
                dp[j] = Math.max(dp[j - W[i]] + V[i], dp[j]);
            }
        }
        System.out.println(dp[K]);
    }
}
```
